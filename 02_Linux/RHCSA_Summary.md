# # RHCSA

## 1. 로컬 및 원격 로그인

### 1-1.

### 1-2. SSH 키 기반 인증 설정

- 개인 키 : ~/.ssh/id_rsa

- 공개 키 : ~/.ssh/id_rsa.pub

- 키 생성

  > ssh-keygen

- 키 복제

  > ssh-copy-id



### 1-3. RedHat Support

- 



## 2. 파일 시스템

### 2-1. 리눅스 파일 시스템 계층 구조

#### 2-1-1. 주요 디렉터리

| 위치  | 용도                                                         |
| ----- | ------------------------------------------------------------ |
| /usr  | 설치된 소프트웨어 프로그램 및 라이브러리 포함<br />- /usr/bin : 사용자 명령<br />- /usr/sbin : 시스템 관리 명령<br />- /usr/local : 로컬 사용자 지정 소프트웨어 |
| /etc  | 시스템 고유의 구성 파일                                      |
| /var  | 재부팅 후에도 존재하는, 시스템 고유의 가변데이터             |
| /run  | 마지막 부팅 이후 시작된 프로세스의 런타임 데이터             |
| /home | 홈디렉터리                                                   |
| /root | 관리자 루트의 홈 디렉터리                                    |
| /tmp  | 어디에서나 쓸 수 있는 임시 파일용 공간<br />10일 동안 액세스, 변경되지 않은 파일은 자동으로 삭제 |
| /boot | 부팅 프로세스를 시작하는 데 필요한 파일                      |
| /dev  | 하드웨어에 액세스하기 위해 사용되는 특수 장치 파일 포함      |

#### 2-1-2. 파일 관리 명령어



#### 2-1-3. 링크 만들기

- 하드 링크

  > 파일 시스템의 기존 파일에 대한 참조를 포함한 새 디렉터리 항목
  >
  > 파일 시스템의 모든 파일은 기본적으로 하나의 하드 링크
  >
  > 공간 절약을 위해, 복사 대신 새 하드 링크를 만들어 동일한 파일 참조 가능

  ```
  ln [기존파일] [하드링크]
  ```

- 소프트 링크(심볼릭 링크)

  > 기존 파일 또는 디렉터리를 가리키는 특별한 유형의 파일

  ```
  ln -s [기존파일] [소프트링크]
  ```

  

## 3. 사용자 및 그룹

### 3-1. 사용자 및 그룹

#### 3-1-1. 사용자

##### username : password : UID : GID : GECOS : /home/dir : shell

- username : UID를 이름으로 매핑
- password
- UID : 사용자를 식별하는 번호
- GID : 사용자의 기본 그룹 ID 번호
- GECOS : 사용자의 실제 이름을 포함한 임의의 텍스트
- /home/dir : 사용자의 개인 데이터 및 구성 파일의 위치
- shell : 사용자가 로그인하면 실행되는 프로그램

#### 3-1-2. 그룹

##### 기본그룹

- 모든 사용자는 하나의 기본 그룹
- 로컬 사용자의 경우, 기본 그룹은 /etc/passwd의 네 번째 필드에 표시도니 그룹의 GID 번호로 식별
- 일반적으로 기본 그룹은 사용자가 만든새 파일을 소유
- 새로 생성된 사용자의 기본 그룹은 사용자와 동일한 이름으로 생성된 그룹

##### 보조 그룹

- 사용자의 0개 이상 보조 그룹의 구성원이 될 수 있음
- 보조 그룹은 사용자가 시스템에 있는 파일 및 다른 리소스에 대한 액세스 권한이 있는지 확인하는데 사용



### 3-2. 수퍼유저 액세스 권한 취득

#### 3-2-1. su

- **su** 명령 사용 시, 다른 사용자 계정으로 전환 가능
- **su -** 사용 시, 루트 전환

#### 3-2-2. sudo

- /etc/sudoers 파일의 설정에 따라 루트 또는 다른 사용자 권한으로 명령 실행
- 사용자가 액세스하려는 계정의 암호가 아닌 자신의 암호를 입력하여 인증
- sudo를 사용한 명령어는 /var/log/secure 에 기록됨



### 3-3. 로컬 사용자 계정 관리

##### useradd

- 옵션 없이 실행하는 경우, /etc/passwd 의 모든 파일에 대한 합리적인 기본 값 설정
- 암호가 설정될 때까지 로그인 할 수 X

##### usermod

- 기존 사용자 수정
- -g : 기본 그룹 지정
- -G : 보조 그룹 지정

##### userdel

- 옵션 없이 사용 시, /etc/passwd 에서 사용자 제거하지만 홈 디렉터리 유지
- -r : 홈 디렉터리 제거

##### UID

- UID 0 : root
- UID 1-200 : RedHat에서 시스템 프로세스에 정적으로 할당 된 "시스템 사용자" 범위
- UID 201-999 : 파일 시스템에 파일을 소유하지 않은 시스템 프로세스에 사용되는 "시스템 사용자" 범위. 이를 필요로 하는 소프트웨어가 설치된 경우 사용 가능한 풀에서 동적으로 할당
- UID 1000 ~ : 정규 사용자에게 할당하는 데 사용 가능한 범위



### 3-4. 로컬 그룹 계정 관리

##### groupadd

- No 옵션 : /etc/login.defs 파일에 지정된 범위에서 사용 가능한 GID 사용
- -g GID : 특정 GID 지정
- -r : /etc/login.defs 파일에 나열된 유효 시스템 GID 번호 범위에서 사용

##### groupmod

- 그룹 이름과 GID 매핑을 변경
- -n : 그룹 새 이름 지정
- -g : 새 GID 지정

##### groupdel

- 그룹 제거

##### usermod

- -aG : 사용자를 보조 그룹에 추가

  ```
  usermod -aG [groupname] [username]
  ```



### 3-5. 사용자 암호 관리

**$1$gCjLa2/Z$6Pu0EK0AzfCjxjv2hoLOB/** 

- 1 : 해시 알고리즘 숫자 1은 MD5 해시, 6은 SHA-512 해사 사용
- gCjLa2/Z : 해시 암호화에 사용되는 salt. 임의로 선택
- 6Pu0EK0AzfCjxjv2hoLOB/  : 암호화된 해시

##### /etc/shadow

```
name:password:lastchange:minage:maxage:warning:inactive:expire:blank
```

1. 로그인 이름
2. 암호화된 암호 / 느낌표로 시작되는 암호 필드는 잠겼음을 의미
3. 마지막 암호 변경 날짜 / 1970년 1월1일 이후 경과된 날짜 수로 표시
4. 암호 변경 전의 최소 날짜 수 / 0은 "최소 변경 요건" 의미
5. 암호 변경 전의 최대 날짜 수
6. 암호 만료를 알리는 경고 기간 / 0은 "경고 없음" 의미
7. 암호가 만료된 후 계정이 계속 활성 상태인 날짜 수
8. 계정 만료 날짜
9. 빈 필드는 향 후 사용을 위해 예약

##### 암호 속성 변경

- chage -d 0 [username] : 다음 로그인 시 암호 업데이트를 강제 수행
- chage -l [username] : 사용자 현재 설정 표시
- chage -E YYYY-MM-DD [username] : 특정 날짜에 계정 만료



### 3-6. ID 관리 서비스

#### 3-6-1. 사용자 정보 및 인증 서비스 

##### 사용자 정보 및 인증

1. 계정 정보 : 사용자 이름, 홈디렉터리 위치, UID 및 GID, 그룹 멤버십 등의 정보가 포함
2. 인증 정보 : 시스템이 사용자의 신원을 검증하는 수단

#### 3-6-2. LDAP 및 kerberos 

##### Authconfig

LDAP 및 Kerberos 서버를 연결하려면 다음 파일을 업데이트

- /etc/openldap/ldap.conf : 중앙 LDAP 서버 및 해당 설정에 대한 내용
- /etc/krb5.conf : 중앙 Kerberos 인프라에 대한 설명
- /etc/sssh/sssd.conf : 사용자 정보 및 인증 정보를 검색 및 캐싱하는 데몬인 system security services daemon(sssd)를 구성
- /etc/nsswitch.conf : 시스템에 사용할 사용자 정보와 인증 서비스를 표시
- /etc/pam.d/* : 다양한 서비스를 위해 인증을 처리할 방법 구성
- /etc/openldap/cacerts : LDAP 서버를 식별하는 데 사용하는 SSL 인증서를 검증할 수 있는 루트 CA 저장

sssd 데몬은 시스템이 사용할 수 있기 전에 활성화 및 시작

RHEL7에서는 자동화할 도구 제공

- authconfig : 명령줄 도구. 구성을 자동화하는데 사용
- authconfig-tui : 대화형 버전
- authconfig-gtk : 그래픽 인터페이스

##### 필수 LDAP 매개 변수

LDAP 연결을 하려면 authconfig에 여러 설정이 필요

- LDAP 서버 호스트 이름
- 환경에는 기본 DN(고유 이름). 기본 DN은 일반적으로 dc=dxample, dc=com 형식. 이 정보는 LDAP 서버 관리자가 제공
- LDAP 서버와의 통신을 암호화하는데 SSL/TLS가 사용된 경우, LDAP 서버에서 인증서를 검증할 수 있는 루트 CA 인증서 제공

##### 필수 Kerberos 매개 변수

- 사용할 Kerberos 영역의 이름
- 하나 이상의 키 배포 센터(KDC). Kerberos 서버의 호스트 이름
- 하나 이상의 관리 서버. 클라이언트가 암호를 변경하거나 기타 사용자 수정을 수행할 경우 통신하는 시스템



## 4. 파일 권한

### 4-1. 파일 시스템 권한 관리

#### 4-1-1. 파일/디렉터리 권한 변경

##### chmod

```
chmod WhoWhatWhich file|directory
chmod ### file|directory
```

- Who : u, g, o(기타), a(모두)
- What : +, -, =
- Which : r, w, x

#### 4-1-2. 파일/디렉터리 사용자 또는 그룹 소유권 변경

##### chown

```
chown [owner] [name]
```

- -R  : 전체 디렉터리 트리의 소유권을 순환적으로 변경

```
chown :[group] [name]
```

- 그룹 소유권 변경

```
chown [owner]:[group] [name]
```

- 소유자, 그룹 동시 변경



### 4-2. 기본 권한 및 파일 액세스 관리

#### 4-2-1. 특수 권한

**setuid** 권한은 해당 명령을 실행한 사용자가 아니라 파일의 user로 실행됨을 의미

| 특수 권한   | 파일                               | 디렉터리                                                     |
| ----------- | ---------------------------------- | ------------------------------------------------------------ |
| u+s(setuid) | 실행자가 아닌 소유자 권한으로 실행 | 영향 X                                                       |
| g+s(setgid) | 소유한 그룹 권한으로 실행          | 디렉터리에 새로 생성된 파일에는 디렉터리의 그룹 소유자와 일치하는 그룹 소유자가 설정 |
| o+t(sticky) | X                                  | 디렉터리에 대한 쓰기 권한을 가진 사용자는 자신이 소유한 파일만 제거 가능 |

#### 4-2-2. 기본 파일 권한

##### umask

- 현재 쉘의 umask 값 표시
- 해당 프로세스에서 생성되는 새 파일과 디렉터리의 권한을 제거하는 데 사용되는 8진수 비트 마스크
- 선행 0 은 특별, 사용자 및 그룹 권한이 지워지지 않음을 의미
- /etc/bashrc, /etc/profile 에서 umask 수정 가능



### 4-3. POSIX ACL

- ACL은 파일 및 디렉터리에 대한 세밀한 액세스 제어 제공
- 파일 시스템은 ACL 지원을 활성화하여 마운트



#### 4-3-1. ACL 권한 적용 순서

- 프로세스가 파일을 소유하고 있는 사용자로 실행되는 경우 파일의 사용자 권한이 적용
- 프로세스가 사용자 ACL 항목에 나열된 사용자로 실행 중인 경우에는 명명된 사용자 ACL 권한이 적용
- 프로세스가 파일의 그룹 소유자와 일치하는 그룹 또는 명시적 명명된 그룹 ACL 항목이 있는 그룹으로 실행되는 경우, 일치하는 ACL 권한이 적용
- 그렇지 않은 경우, 파일의 other ACL 사용 권한 적용



### 4-4. ACL로 파일 보호

#### 4-4-1. ACL 파일 권한 변경

##### ACL 추가 또는 수정

```
setfacl -m u:[name]:[rwx] [file]
```

name이 비어 있는 경우, file owner에 적용

```
setfacl -m g:[name]:[rwx] [file]
```

group에 적용. name이 비어 있는 경우, group owner에 적용

##### getfacl을 입력으로 사용

getfacl의 출력을 setfacl에 대한 입력으로 사용 가능

```
getfacl fileA | setfacl --set-file=- fileB
```

##### 명시적 ACL 마스크 설정

파일 또는 디렉터리에 ACL 마스크를 명시적으로 설정하여 명명된 사용자, 그룹 소유자, 명명된 그룹의 최대 유효 권한 제한 가능

```
setfacl -m m::[rwx] [file]
```

##### ACL 삭제

```
setfacl -x u:[name],g:[name] [file]
```



#### 4-4-2. 기본 ACL 파일 권한 제어

```
setfacl -m d:u:[name]:[rwx] [directory]
```



## 5. SELinux

### 5-1. SELinux 활성화 및 모니터링

##### 기본 SELinux 보안 개념

- SELinux의 기본 목적은 손상된 시스템 서비스로부터 사용자 데이터를 보호
- 개체 기반이며 더 정교한 규칙으로 제어되는 MAC(Mandatory Access Control)이라는 추가 보안 레이어 제공
- 어느 프로세스가 어느 파일, 디렉터리, 포트에 액세스할 수 있는지 결정하는 보안 규칙의 집합
- 컨텍스트는 SELinux 정책에서 프로세스가 파일, 디렉터리, 포트에 액세스할 수 있는지를 결정하는데 사용하는 이름

##### SELinux 모드

- 강제모드 : 로그와 보호를 모두 수행
- 허용모드 : 문제해결에 주로 사용 / SELinux가 제한하고 있는 컨텐츠에 대한 액세스를 일시적으로 허용하는 데 사용
- disabled : SELinux 완전히 비활성화

##### 현재 SELinux 모드 표시

```text
getenforce
```



### 5-2. SELinux 모드 변경

##### 현재 SELinux 모드 변경

``` text
setenforce [Enforcing | Permissive | 1 | 0 ]
```

- 1 = 강제모드
- 0 = 허용모드
- selinux=0 비활성화

##### 기본 SELinux 모드 설정

부팅 시 SELinux 모드를 결정하는 구성 파일은 **/etc/selinux/confi**



### 5-3. SELinux 컨텍스트 변경

##### 초기 SELinux 컨텍스트

- 파일의 상위 디렉터리의 SELinux 컨텍스트에 따라 초기 SELinux 컨텍스트 결정

##### 파일의 SELinux 컨텍스트 변경

- chcon
  - 파일의 컨텍스트를 명령의 인수로 지정된 컨텍스트로 변경

- restorecon
  - 파일 또는 디렉터리의 컨텍스트 변경
  - 컨텍스트를 명시적으로 지정하지 X
  - SELinux 정책에 규칙을 사용하여 파일의 컨텍스트를 결정

##### SELinux 기본 파일 컨텍스트 규칙 정의

- **semanage manage**명령을 사용하여 restorecon 이 기본 파일 컨텍스트를 설정할 때 사용하는 규칙을 표시하거나 수정 가능
- 정규표현식을 사용하여 경로 및 파일 이름을 지정



### 5-4. SELinux 부울 변경

##### SELinux 부울

- SELinux 정책의 동작을 변경하는 스위치
- 활성화하거나 비활성화할 수 있는 규칙

```text
getsebool
```

```text
setsebool
```



## 6. 프로세스 관리

### 6-1. 프로세스 kill

##### 신호를 사용하여 프로세스 제어

- 신호는 프로세스에 전달된 소프트웨어 인터럽트

| 신호 번호   | 이름 | 정의            | 용도                                                         |
| ----------- | ---- | --------------- | ------------------------------------------------------------ |
| 1           | HUP  | 끊어짐          | 터미널의 제어 프로세스 종료를 보고하는 데 사용 / 프로세스를 초기화 하는데 사용 |
| 2           | INT  | 키보드 인터럽트 | 프로그램 종료                                                |
| 3           | QUIT | 키보드 종료     | SIGINT와 유사하지만 종료할 때 프로세스 덤프 발생             |
| 9           | KILL | 킬              |                                                              |
| 15(Default) | TERM | 종료            |                                                              |
| 18          | CONT | 계속            |                                                              |
| 19          | STOP | 중지            |                                                              |
| 20          | TSTP | 키보드 중지     |                                                              |

- **kill** 명령은 ID로 프로세스에 신호를 전송

```text
kill -signal PID
```

- **killall** 은 선택 기준에 맞는 하나 이상의 프로세스에 신호 전송
- **pkill** 명령은 복수의 프로세스 신호 전송 가능
  - Command - 명령 이름의 패턴이 일치하는 프로세스
  - UID - Linux 사용자 계정이 소유한 유효한 프로세스
  - GID - Linux 그룹 계정이 소유한 유효한 프로세스
  - Parent - 특정 상위 프로세스의 하위 프로세스
  - Terminal - 특정 제어 터미널에서 실행되는 프로세스



### 6-2. 프로세스 작업 모니터링





